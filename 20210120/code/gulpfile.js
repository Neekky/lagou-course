const gulp = require('gulp')
const webpack = require('webpack-stream')

gulp.task('default', function () {
  return gulp.src('src/index.js')
    .pipe(webpack())
    .pipe(reanme())
    .piep(mincss())
    .pipe(gulp.dest('dist/'))
})

/**
 * gulp 的设计哲学是一个管道流 + 任务调度 它本身不会做任何事情
 * 管道流： 相当于有一个管道，它里面走的都是数据
 * 任务调度： 每一次使用 pipe 的时候，就是我们要做一件事情
 *
 * babel 如果我们在 gulp 中使用了，它也是负责语法的兼容性处理，例如我们在 web环境下可能无法使用 类这种语法
 * 它会负责转换，但是它不能实现打包
 *
 * 上述的 webpack 是一个函数名，它是执行了 require 操作之后导入的
 *
 * webpack-stream必然是一个模块，导出的内容被  webpack 接收
 * webpack-stream这个模块其实就是一个插件
 *
 * 插件是用Node.js 编写的一个模块，然后它导出的是一个函数，使用的时候调用就行了
 * webpack 中的插件都是类 new HtmlWebpackPlugin()
 *
 * 经过上面的内容我们知道 使用 gulp 配合 webpack-stream 可以实现js 的模块导入及打包操作
 *  01 打包操作不是 gulp 做的， 是插件做的
 *  02 通过这个例子我们好像可以说 gulp 更 “大” 一些
 *
 * 微信小程序开发：
 *  小程序的规则是一个界面就是一套（html css js )
 *  webpack ： 使用它的话，如果我们的 entry 是一个入口，那么将来出来的10有89 是一个文件（没考虑优化）
 *  gulp: 此时采用 gulp 就很合理，它只负责执行任务，至于说是什么样的任务，由你来决定
 *
 *  打包和压缩（工程化操作中去理解）
 *    打包：
 *      （ 模块化演示历史 ）
 *      包是什么？ 在没有工程化之前我们就是 html  css  js 一个一个的写
 *      只不过随着工程化的出现，我们慢慢的采用了 模块化开发的思路
 *      所谓的模块化是什么？一切皆模块，将我们整个应用在开的时候所涉及到的代码拆分成很多个模块（ 函数 ）
 *      此时就相当于是将一个很大的 JS 文件拆分成了N 个 JS ，我们将每个 JS 都可以称之为一个模块
 *      分完之后的好处就是在开发的时候会特别的爽，但是上线的代码不可能分成 N 个模包，因此在上线的时候就需要
 *      将这些分散的模块合起来，这个过程我们就叫打包 （仍据入口，然后找到他的所有依赖，将它们处理成一个文件）
 *    压缩
 *      线上运行的时候我们需要考虑优化，那么资源的大小肯定是一个问题
 *
 *
 */