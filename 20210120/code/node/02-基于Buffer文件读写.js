// 我们可以自由的来申请一个大小的内存，做为读写时的缓冲

const fs = require('fs')

// 自己申请空间[ 此处的内存大小虽然由我们自己来申请，但是它的回收不是由我们来做 ]
// buf 类似于数组，可以通过下标进行访问
let buf = Buffer.alloc(100)

// fs.open('./test.txt', (err, fd) => {
//   // node 中的 fd是将多个平台上的文件操作符抽象之后的内容，我们称之为叫标识符
//   // 利用这个 fd 系统最终可以找到一个对应的文件。
//   // 默认情况下从 3 开始，因为在 node 中有： 标准输入 标准输出 标准错误 

//   // 此处的读就是写： 我们现在可以通过read将某一个文件中的数据读出来，读出来的数据最终是要存的
//   // 因此这时我们当初自己申请的那个空间就有用了，也就是将内容写到那个空间里 
//   /**
//    * fd 用于指定读取哪个文件里的数据
//    * buf 用于指定将数据写到哪片空间里
//    * 10 表示从buf 的哪个位置上写 
//    * 6 表示当前次读取的字节数 
//    * 3 表示从 fd 的哪个位置上开始读
//    */
//   fs.read(fd, buf, 10, 6, 3, (err, bytesRead) => {
//     console.log(bytesRead)  // 看它写几个
//     console.log(buf.toString())  // 看它写了多少个
//   })
// })

buf = Buffer.from('坚持一下，有你们我开心')

// 写操作
fs.open('test2.txt', 'w', (err, fd) => {

  // 这里的写就是指将数据从 内存中取出来，然后写入指定的磁盘文件里
  fs.write(fd, buf, 3, 3, (err, written, buffer) => {
    console.log('写操作成功')
  })
})

/**
 * JS 可以在 node平台下操作二进制
 * 使用了 readFile writeFile ，但是二进对内存空间不友好
 *
 * open
 * read
 * write
 * Buffer.alloc
 * Buffer.from
 *
 *
 * 当前我们有一个文件 A ,它里面存放了 1G的数据，需求，利用 open  read write 将这些内容拷贝至 B 文件
 *  01 此时我们需要自定义一个 buffer 来做为缓存冲  ，问题就是我们设置多少合适， 100KB
 *  02 如果此时我们设置了 100KB ，那么在写代码的时候就会出现很多的嵌套和递归调用
 *
 * 流操作
 */